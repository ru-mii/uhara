using SharpDisasm;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public partial class Tools : MainShared
{
    public partial class UnrealEngine
    {
        public void SetMaxFPS(float fps)
        {
            string uniqueId = "sQIVnTDyJEEQhuUt";
            bool success = false;
            try
            {
                do
                {
                    // ---
                    fps = (int)(fps);

                    // ---
                    ProcessInstance = TProcess.RefreshProcess(ProcessInstance);
                    if (ProcessInstance.ProcessName != "VanWheelGone-Win64-Shipping")
                        break;

                    MemoryManager.ClearMemory(uniqueId);

                    // ---
                    ulong scanResult = TMemory.ScanSingle(ProcessInstance, "48 8B 0D ?? ?? ?? ?? 0F 57 C9 F3 0F 5F C1 48 8B 01 0F 28 C8 FF 90", null, 0x20);
                    if (scanResult == 0) break;

                    Instruction[] instrs = TInstruction.GetInstructions2(TMemory.ReadMemoryBytes(ProcessInstance, scanResult, 0x100), scanResult);
                    if (!instrs[0].ToString().StartsWith("mov rcx, [rip")) break;
                    if (instrs.Length < 10) break;

                    // ---
                    ulong gEnginePtr = 0;
                    {
                        int value = TMemory.ReadMemory<int>(ProcessInstance, scanResult + 3);
                        gEnginePtr = (ulong)((long)scanResult + value + 7);
                    }
                    if (gEnginePtr == 0) break;

                    // ---
                    int setFpsVtableOffset = 0;
                    {
                        for (int i = 0; i < 10; i++)
                        {
                            if (!instrs[i].ToString().StartsWith("call qword [r")) continue;
                            string parsed = instrs[i].ToString();
                            parsed = parsed.Remove(parsed.IndexOf("]"));
                            parsed = parsed.Substring(parsed.IndexOf("0x"));
                            setFpsVtableOffset = TConvert.Parse<int>(parsed);
                            break;
                        }
                    }
                    if (setFpsVtableOffset == 0) break;

                    // ---
                    if (TProcess.GetModuleBase(ProcessInstance, "kernel32.dll") == 0) break;
                    ulong sleep = TProcess.GetProcAddress(ProcessInstance, "kernel32.dll", "Sleep");
                    if (sleep == 0) break;

                    // ---
                    ulong allocated = MemoryManager.AllocateSafe(0x1000, uniqueId);
                    if (allocated == 0) break;

                    // ---
                    // gEnginePtr
                    // setFpsVtableOffset
                    // sleep
                    {
                        #region ASM_CODE
                        byte[] AsmCode = new byte[] {
    0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0x48, 0x90, 0x81, 0x90, 0xEC, 0x90, 0x40, 0x90, 0x01, 0x90, 0x00, 0x90, 0x00, 0x90, 0x50, 0x90, 0x53, 0x90, 0x51, 0x90, 0x52, 0x90, 0x56, 0x90, 0x57, 0x90, 0x55, 0x90, 0x54, 0x90, 0x41, 0x90, 0x50, 0x90, 0x41, 0x90, 0x51, 0x90, 0x41, 0x90, 0x52, 0x90, 0x41, 0x90, 0x53, 0x90, 0x41, 0x90, 0x54, 0x90, 0x41, 0x90, 0x55, 0x90, 0x41, 0x90, 0x56, 0x90, 0x41, 0x90, 0x57, 0x90, 0x9C, 0x90, 0x48, 0x90, 0x83, 0x90, 0xEC, 0x90, 0x08, 0x90, 0x48, 0x90, 0x83, 0x90, 0xEC, 0x90, 0x28, 0x90, 0xFF, 0x90, 0x35, 0x90, 0xAA, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0x58, 0x90, 0x48, 0x90, 0x85, 0x90, 0xC0, 0x90, 0x0F, 0x90, 0x84, 0x90, 0xA9, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0xFF, 0x90, 0x35, 0x90, 0xA2, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0x58, 0x90, 0x48, 0x90, 0x85, 0x90, 0xC0, 0x90, 0x0F, 0x90, 0x84, 0x90, 0x99, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0xFF, 0x90, 0x35, 0x90, 0x9A, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0x58, 0x90, 0x48, 0x90, 0x85, 0x90, 0xC0, 0x90, 0x0F, 0x90, 0x84, 0x90, 0x89, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0xFF, 0x90, 0x35, 0x90, 0x92, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0x58, 0x90, 0x48, 0x90, 0x85, 0x90, 0xC0, 0x90, 0x74, 0x90, 0x7D, 0x90, 0x48, 0x90, 0xC7, 0x90, 0xC6, 0x90, 0x1E, 0x90, 0x00, 0x90, 0x00, 0x90, 0x00, 0x90, 0xEB, 0x90, 0x25, 0x90, 0xFF, 0x90, 0x35, 0x90, 0x85, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0x58, 0x90, 0x48, 0x90, 0x83, 0x90, 0xF8, 0x90, 0x01, 0x90, 0x74, 0x90, 0x67, 0x90, 0x48, 0x90, 0x85, 0x90, 0xF6, 0x90, 0x74, 0x90, 0x62, 0x90, 0x48, 0x90, 0xFF, 0x90, 0xCE, 0x90, 0x48, 0x90, 0xC7, 0x90, 0xC1, 0x90, 0xE8, 0x90, 0x03, 0x90, 0x00, 0x90, 0x00, 0x90, 0xFF, 0x90, 0x35, 0x90, 0x61, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0x58, 0x90, 0xFF, 0x90, 0xD0, 0x90, 0xFF, 0x90, 0x35, 0x90, 0x48, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0x58, 0x90, 0x48, 0x90, 0x8B, 0x90, 0x00, 0x90, 0x48, 0x90, 0x85, 0x90, 0xC0, 0x90, 0x74, 0x90, 0xCC, 0x90, 0x48, 0x90, 0x89, 0x90, 0xC1, 0x90, 0x48, 0x90, 0x8B, 0x90, 0x00, 0x90, 0x48, 0x90, 0x85, 0x90, 0xC0, 0x90, 0x74, 0x90, 0xC1, 0x90, 0xFF, 0x90, 0x35, 0x90, 0x36, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0x41, 0x90, 0x58, 0x90, 0x4C, 0x90, 0x01, 0x90, 0xC0, 0x90, 0x48, 0x90, 0x8B, 0x90, 0x00, 0x90, 0x48, 0x90, 0x85, 0x90, 0xC0, 0x90, 0x74, 0x90, 0xAE, 0x90, 0xFF, 0x90, 0x35, 0x90, 0x13, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0xFF, 0x90, 0x41, 0x90, 0x58, 0x90, 0x66, 0x90, 0x49, 0x90, 0x0F, 0x90, 0x6E, 0x90, 0xC0, 0x90, 0x66, 0x90, 0x49, 0x90, 0x0F, 0x90, 0x6E, 0x90, 0xC8, 0x90, 0x48, 0x90, 0x31, 0x90, 0xD2, 0x90, 0x4D, 0x90, 0x31, 0x90, 0xC0, 0x90, 0x4D, 0x90, 0x31, 0x90, 0xC9, 0x90, 0xFF, 0x90, 0xD0, 0x90, 0x48, 0x90, 0x85, 0x90, 0xC0, 0x90, 0x74, 0x90, 0x8C, 0x90, 0x48, 0x90, 0x83, 0x90, 0xC4, 0x90, 0x28, 0x90, 0x48, 0x90, 0x83, 0x90, 0xC4, 0x90, 0x08, 0x90, 0x9D, 0x90, 0x41, 0x90, 0x5F, 0x90, 0x41, 0x90, 0x5E, 0x90, 0x41, 0x90, 0x5D, 0x90, 0x41, 0x90, 0x5C, 0x90, 0x41, 0x90, 0x5B, 0x90, 0x41, 0x90, 0x5A, 0x90, 0x41, 0x90, 0x59, 0x90, 0x41, 0x90, 0x58, 0x90, 0x5C, 0x90, 0x5D, 0x90, 0x5F, 0x90, 0x5E, 0x90, 0x5A, 0x90, 0x59, 0x90, 0x5B, 0x90, 0x58, 0x90, 0x48, 0x90, 0x81, 0x90, 0xC4, 0x90, 0x40, 0x90, 0x01, 0x90, 0x00, 0x90, 0x00, 0x90, 0xC3
};
                        #endregion

                        byte[] decoded = TArray.DecodeBlock(AsmCode);
                        RefWriteBytes(ProcessInstance, allocated, decoded);

                        RefWriteBytes(ProcessInstance, allocated, BitConverter.GetBytes(fps)); allocated += 0x8;
                        RefWriteBytes(ProcessInstance, allocated, BitConverter.GetBytes(gEnginePtr)); allocated += 0x8;
                        RefWriteBytes(ProcessInstance, allocated, BitConverter.GetBytes(setFpsVtableOffset)); allocated += 0x8;
                        RefWriteBytes(ProcessInstance, allocated, BitConverter.GetBytes(sleep)); allocated += 0x8;
                        MemoryManager.AddOverwrite(allocated, BitConverter.GetBytes((ulong)1)); allocated += 0x8;

                        ulong threadHere = allocated;
                        allocated += (ulong)decoded.Length;

                        TProcess.CreateRemoteThread(ProcessInstance, threadHere);
                    }

                    // ---
                    TUtils.Print("Utils | FPS locked to " + fps.ToString());
                    success = true;
                }
                while (false);
            }
            catch { }
            if (!success)
            {
                TUtils.Print("Utils | \"SetMaxFPS\" failed, retrying...");
                Thread.Sleep(1000);
                throw new Exception();
            }
        }

        public void LockFps(float fps)
        {
            return;
            string uniqueId = "NTpcAJCLFFCMrnGv";
            bool success = false;
            try
            {
                do
                {
                    ProcessInstance = TProcess.RefreshProcess(ProcessInstance);
                    MemoryManager.ClearMemory(uniqueId);

                    // ---
                    fps = (int)(fps);

                    // ---
                    ulong address = TMemory.ScanSingle(ProcessInstance, "EB 03 0F 28 C6 48 8B 5C 24 ?? 0F 28 74 24 ?? 44 0F 28 ?? 24 ?? 44 0F 28 4C 24 ?? 48 83 C4 ?? 5F C3", null, 0x20);
                    if (address == 0) TMemory.ScanSingle(ProcessInstance, "EB 03 0F 28 C6 48 8B 5C 24 ?? 0F 28 74 24 ?? 44 0F 28 ?? 24 ?? 48 83 C4 ?? 5F C3", null, 0x20);
                    if (address == 0) break;

                    // ---
                    byte[] ending = TMemory.ReadMemoryBytes(ProcessInstance, address, 0x100);
                    if (ending == null) break;

                    Instruction[] instrs = TInstruction.GetInstructions2(ending, address);
                    if (instrs == null || instrs.Length < 3) break;

                    if (instrs[1].ToString() != "movaps xmm0, xmm6") break;

                    // ---
                    ulong allocated = MemoryManager.AllocateSafe(0x1000, uniqueId);

                    address = instrs[2].Offset;
                    int minimumOverwrite = TInstruction.GetMinimumOverwrite(ProcessInstance, address, 14);
                    if (minimumOverwrite == 0) break;

                    byte[] stolen = TMemory.ReadMemoryBytes(ProcessInstance, address, minimumOverwrite);
                    if (stolen == null) break;
                    MemoryManager.AddOverwrite(address, stolen, uniqueId);

                    RefWriteBytes(ProcessInstance, allocated, BitConverter.GetBytes(fps));
                    allocated += 0x8;

                    ulong myCodeStart = allocated;

                    byte[] overwriteXmm = new byte[] { 0x50, 0x48, 0x8B, 0x05, 0xF0, 0xFF, 0xFF, 0xFF, 0x66, 0x48, 0x0F, 0x6E, 0xC0, 0x58 };
                    RefWriteBytes(ProcessInstance, allocated, overwriteXmm);
                    allocated += (ulong)overwriteXmm.Length;
                    RefWriteBytes(ProcessInstance, allocated, stolen);
                    allocated += (ulong)stolen.Length;

                    TMemory.CreateAbsoluteJump(ProcessInstance, allocated, address + (ulong)minimumOverwrite);
                    TMemory.CreateAbsoluteJump(ProcessInstance, address, myCodeStart);

                    // ---
                    TUtils.Print("Utils | FPS locked to " + fps.ToString());
                    success = true;
                }
                while (false);

            }
            catch { }
            if (!success)
            {
                TUtils.Print("Utils | \"LockFps\" failed, retrying...");
                Thread.Sleep(1000);
                throw new Exception();
            }
        }

        public string FNameToString(uint fName)
        {
            try
            {
                do
                {
                    ulong FNamePoolAddress = ToolsShared.ToolData.UnrealEngine.D_FNamePoolAddress;
                    if (FNamePoolAddress == 0) break;

                    var nameIdx = (fName & 0x000000000000FFFF) >> 0x00;
                    var chunkIdx = (fName & 0x00000000FFFF0000) >> 0x10;
                    var number = (fName & 0xFFFFFFFF00000000) >> 0x20;

                    IntPtr chunk = (IntPtr)TMemory.ReadMemory<ulong>(ProcessInstance,
                        FNamePoolAddress + (ulong)(0x10 + (int)chunkIdx * 0x8));

                    IntPtr entry = chunk + (int)nameIdx * sizeof(short);
                    int length = TMemory.ReadMemory<short>(ProcessInstance, entry) >> 6;
                    if (length > byte.MaxValue || length <= 0) break;

                    return TUtils.MultibyteToString(TMemory.ReadMemoryBytes(ProcessInstance, entry + sizeof(short), length));
                }
                while (false);
            }
            catch { }
            return null;
        }
    }
}